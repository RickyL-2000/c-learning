# 函数

## 函数的声明

即函数的原型
编译器要知道函数返回值的类型，才能知道有多少字节的数据，以及如何解释它们。这就是为什么必须声明函数的原因。

example: 

    int function (int n, int m); //分号表明这是在声明

**NOTE**：函数的原型可以置于mian()函数的前面，也可以放在main()函数里面的声明变量处，放在哪个位置都可以。

函数的声明可以省略形参名，只声明形参类型
example:

    void show_n_char(char, int);



## 函数的定义

可以把函数的定义和main()函数分别放在不同的文件中，把#define和#include指令放入该文件。

形参(parameter)，实参(argument)。在C99的标准中，这两个英文单词是不能互换的。

在创建自己的函数的同时，还可以创建一个简单的main()函数，用于检查函数是否正常工作。这种被设计用于测试函数的程序有时被称为驱动程序(driver)。如果函数成功通过了测试，就可以安装在一个更重要的程序中使用。

**NOTE**：要求所有形参都有自己的定义，example:

    double function(double a, b);         //无效
    double function(double a, double b);  //有效

函数的类型指的是函数返回值的类型，而不是参数的类型



### 返回值

**NOTE**：
1. 函数名前有void关键字的函数**没有返回值**
2. 在圆括号中的void表明该函数不带参数
3. return之后可以不加任何语句，如下：

        return;
    这条语句会导致终止函数，并把控制返回给主调函数。因为return后面没有任何表达式，所以没有返回值。只有在void函数中才会用到这种形式
4. 甚至可以没有return语句（似乎有点method的感觉）

定义函数时返回值的类型需要在函数名前标出

> example: power.c

example:

    double power (double n, int p)
    {
        double pow = 1;
        int i;

        for (i = 1; i <= p; i++)
            pow *= n;
        
        return pow;   //返回pow的值
    }

### ANSI C函数原型 (?)




## 函数的调用

使用return从函数中返回值。


## 递归

> example: recur.c

C允许函数调用自己，这种调用过程成为递归(recursion)。结束是使用递归的难点，因为如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。递归方案更简洁，但是效率没有循环高。

**NOTE**：
1. 递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。
2. 递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。


### 尾递归

最简单的递归形式是把递归调用置于函数的末尾，即正好在return之前。这种形式的递归被成为尾递归(tail recursion)。这种递归是最简单的递归形式，因为它相当于循环。

example(这个例子是关于一个正整数的阶乘):

    long fact(int n)  //使用循环的函数
    {
        long ans;
        for (ans = 1; n > 1; n--)
            ans *= n;
        return ans;
    }

    long rfact(int n)  //使用递归的函数
    {
        long ans;
        if (n > 0)
            ans = n* rfact(n - 1);
        else
            ans = 1;
        
        return ans
    }

### 递归和倒序计算

递归在处理倒序时非常方便（在解决这类问题中，递归比循环简单）

**example:** 

我们要设计一个以二进制形式表示整数的算法。在二进制中，奇数的末尾一定是1，偶数的末尾一定是0，所以通过5 % 2即可确定5的二进制数的最后一位是1还是0。一般而言，对于数字n，其二进制的最后一位就是n % 2。因此，计算出的第一位数字实际上是待输出二进制数的最后一位。**这一规律提示我们，在递归函数的递归调用之前计算n % 2，在递归调用之后打印计算结果。**

要计算二进制数n，首先计算n%2，将余数作为最后一位二进制数，再求n/2(整数除法)，对求得的数再进行取模...这样所有的余数就都可以作为二进制数的每一位了。

### 递归的优缺点

优点是递归为某些编程问题提供了最简单的解决方案。

缺点是一些递归算法会快速消耗计算机的内存资源。

## 编辑多源代码文件的程序 (????????????????????????????????)



## 基本函数

### strlen()函数

包含在string.h头文件中

给出字符串中的字符长度(string)，而且**忽略空字符**。而**sizeof**运算符是以字节为单位给出对象的大小。




**(?)**
为什么如下程序不行？？？

    #include <stdio.h>
    int main()
    {
        printf("Enter an ASCII code:\n");
        int code;
        scanf("d%\n", &code);
        printf("%c\n", code);
        return 0;
    }