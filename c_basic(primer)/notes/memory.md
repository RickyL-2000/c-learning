# 存储类别、链接和内存管理

## 存储类别

## 随机数函数和静态变量

## 分配内存

可以更灵活地选择内存分配，即用库函数分配和管理内存。

回顾一下内存分配：

    float x;
    char place[] = "Dancing Oxen Creek"; //为一个float类型的值和一个字符串预留了足够的内存。
    int plates[100]; //显式指定分配一定数量的内存。预留了100个内存位置

> dyn_arr.c

### malloc()

原型在stdlib.h头文件中

使用malloc()函数，C可以在程序运行时分配更多的内存。该函数接受一个参数：所需的内存字节数。malloc()会找到合适的空闲内存块，这样的内存是匿名的。也就是说，malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。

因为char表示1字节，malloc()的返回类型通常被定义为指向char的指针。然而，从ANSI C标准开始，C使用一个新的类型：指向void的指针。该类型相当于一个"通用指针"。malloc()函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。

如果malloc()分配内存失败，将返回空指针。

example:

    double *ptd;
    ptd = (double *) malloc(30 * sizeof(double));

以上代码为30个double类型的值请求内存空间，并设置ptd指向该位置。注意，指针ptd被声明为指向一个double类型，而不是指向内含30个double类型值的块。此时，可以像访问数组一样访问该块内存

如果malloc()分配不到所需的内存。在这种情况下，该函数会返回空指针。

同时，在C99之后，该数组的创建方式可以创建动态内存，即把式中的30换成变量。这比变长数组更灵活。

**NOTE**：在C中，不一定要使用强制类型转换(double *)，但是在C++中必须使用。所以，使用强制类型转换更容易把C程序转换为C++程序。

使用malloc()，程序可以在运行时才确定数组的大小。

通常，malloc()要与free()配套使用。

### free()

原型在stdlib.h头文件中

free()函数的参数是之前malloc()返回的地址，即一个指针，该函数释放之前malloc()分配的内存。因此，动态分配内存的存储器从调用malloc()分配内存到free()释放内存为止。

**NOTE**：
1. 不能用free()释放通过其他方式(如，声明一个数组)分配的内存。
2. 一些操作系统在程序结束时会自动释放动态分配的内存，但是有些系统不会。保险起见还是使用free()，不要依赖操作系统来清理。
3. 静态内存的数量在编译时是固定的，但是动态分配的内存数量只会增加，除非用free()进行释放。假如未调用free()释放这块内存，就有可能在循环结束之前就耗尽所有的内存。这类问题被称为内存泄漏(memory leak)。
4. 不能释放同一块内存两次(会怎么样？)

### exit()

原型在stdlib.h头文件中

如果在调用malloc()过程中，内存分配失败，可以调用exit()函数结束程序。

标准提供了两个返回值以保证在所有操作系统中都能正常工作：EXIT_SUCCESS(或者，相当于0)表示普通的程序结束，EXI_FAILURE表示程序异常中止。一些操作系统(包括UNIX、Linux和Windows)还接受一些表示其他运行错误的整数值

### calloc()

分配内存还可以使用calloc()，典型的用法如下：

    long * newmem;
    newmem = (long *) calloc(100, sizeof(long));

和malloc()类似，在ANSI C之前，calloc()也返回指向char的指针，之后就返回指向void的指针。如果要储存不同的类型，应使用强制类型转换运算符。

calloc()函数接受两个无符号整数作为参数(ANSI规定是size_t类型)。第一个参数是所需的存储单元数量，第二个是存储单元的大小(以字节为单位)。

**NOTE**：
1. calloc()函数把内存块中的所有位都设置为0(在某些硬件系统中，不是把所有位都设置为0来表示浮点值0)
2. free()函数也可以用于释放calloc()分配的内存


### 动态内存分配和变长数组

变长数组是自动存储类型。因此，程序在离开变长数组定义所在的块时，变长数组占用的内存空间会被自动释放，不必使用free()。另一方面，用malloc()创建的数组不必局限在一个函数内访问。例如可以在主调函数中释放之前被调函数中分配的内存。

另外，free()所用的指针变量可以与malloc()的指针变量不同，但是两个指针必须储存相同的地址。但是不能释放同一块内存两次。

#### 多维数组

对于多维数组而言，使用变长数组更方便。当然，也可以用malloc()创建二维数组，但是语法比较繁琐。example:

    int n = 5;
    int m = 6;
    int ar2[n][m];
    int (* p2)[6];
    //由于malloc()函数返回一个指针，所以p2必须是一个指向合适类型的指针：指向一个内含6个int类型值的数组
    int (* p3)[m];
    p2 = (int (*)[6]) malloc(n * 6 * sizeof(int)); //nx6
    p3 = (int (*)[m]) malloc(n * m * sizeof(int)); //nxm
    ar[1][2] = p2[1][2] = 12;

### 存储类别和动态内存分配