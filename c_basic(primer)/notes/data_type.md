# 基本数据类型

|    type     |      name      |       space       |
| :---------: | :------------: | :---------------: |
|    bool     |      布尔      |        无         |
|    char     |      字符      |      8位bit       |
|   wchar_t   |     宽字符     |       16位        |
|  charl16_t  |  Unicode 字符  |       16位        |
|  charl32_t  |  Unicode 字符  |       32位        |
|    short    |     短整型     |       16位        |
|     int     |      整型      |      16/32位      |
|    long     |     长整型     |       32位        |
|  long long  |     长整型     |       64位        |
|  unsigned   |   无符号整数   |         ?         |
|    float    |  单精度浮点数  | 6位有效数字 32位  |
|   double    |  双精度浮点数  | 13位有效数字 64位 |
| long double | 扩展精度浮点数 | 至少13位有效数字  |


**NOTE**
1. 对于float类型，正号可以省略，可以没有小数点（如2E5）或指数部分（如19.28），但是不能同时省略两者。可以省略小数部分（如3.E16）或整数部分（如.45E-1）。但是不能同时省略两者。不能在有效数字和"E"之间加空格。
2. 在浮点数后面加上f或者F可以覆盖默认设置，编译器会将浮点型常量看作float类型，如2.3f和9.11E9F。使用l或者L后缀使数字成为long double类型，而且建议使用L后缀，因为l后缀容易与数字1混淆。没有后缀的浮点型常量是double类型。
3. 默认情况下，编译器假定浮点型常量是double类型的精度
4. C99标准新加：用十六进制表示浮点型常量(???)
5. 将一个char和int相加并赋给一个char类型，得到的是这个char的ASCII码加上int后的ASCII码所对应的字符。若赋给一个int类型，则是得到相加之后的ASCII码
6. 字符串如何相加????



### 复数和虚数类型

|          type          | form  |
| :--------------------: | :---: |
|     float _Complex     |   ?   |
|    double _Complex     |   ?   |
|  long double _Complex  |   ?   |
|    float _Imaginary    |   ?   |
|   double _Imaginary    |   ?   |
| long double _Imaginary |   ?   |

**NOTE**：如果包含complex.h头文件，便可用complex代替_Complex，用imaginary代替_Imaginary，还可以用I代替-1的平方根。


转义序列
|  ESC  |      meaning       |
| :---: | :----------------: |
|  \a   |        警报        |
|  \b   |        退格        |
|  \f   |        换页        |
|  \n   |        换行        |
|  \r   |        回车        |
|  \t   |     水平制表符     |
|  \v   |     垂直制表符     |
|  \\   |       反斜杠       |
|  \'   |       单引号       |
|  \"   |       双引号       |
|  \?   |        问号        |
| \0oo  |  八进制值(oo是数)  |
| \xhh  | 十六进制值(hh是数) |


## 类型大小 (?)

> example: typesize.c

用sizeof()函数返回string_size格式的类型大小

## 可移植类型: stdint.h 和 inttypes.h (??)

C99新增了两个头文件 stdint.h 和 inttypes.h，以确保C语言的类型在各系统中的功能相同。

## 程序的上溢(overflow)和下溢(underflow)

> example: overflow_and_underflow.c

当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢，此时会赋一个表示无穷大的特定值，比如inf或者infinity

而当除以一个很小的数时，情况更为复杂(?)

还有一个特殊的浮点值NaN(not a number的suoxie)。比如给反正弦函数输入了大于1的变量，返回的就是NaN。

**NOTE**：浮点数并不精确！

## 类型转换

基本的类型转换规则
1. 当类型转换出现在表达式时，无论是unsigned还是signed得char和short都会被自动转换成int，如有必要会被转换成unsigned int。由于都是较小类型转换为较大类型，所以这些转换被称为升级(promotion)
2. 涉及两种类型得运算，两个值会被分别转换成两种类型得更高级别
3. 类型得级别从高到低依次是
4. 赋值表达式语句中，计算得最终结果会被转换成被赋值变量得类型。这个过程可能导致类型升级或降级。
5. 当作为函数参数传递时，char和short倍转换成int, float被转换成double。
   

### 强制类型转换运算符

将其右侧得值转换成圆括号中指定得类型。

example:

    int mice;
    mice = (int)1.6 + (int)1.7;  //强制把1.6和1.7都变成1



## 指针

指针用于储存变量的地址，根本上是一个值为内存地址的变量（或数据对象）。如果主调函数不使用return返回的值，则必须通过地址才能修改主调函数中的值。(?)

因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。

### 地址运算符&

地址运算符&给出变量的存储地址。example:

    pooh = 24; //假设pooh的存储地址是0B76(PC地址通常用十六进制形式表示)
    printf("%d %p\n", pooh, &pooh) //如果pooh是变量名，那么&pooh是变量的地址
这将输出以下内容:

    24 0B76
在C中，调用函数只是把main中的实际参数的值传递给形式参数，涉及的两个变量并未改变。所以局域变量和全局变量的名称可能相同。但这并不是在所有语言中成立(如FORTRAN)

假设一个指针的变量名是ptr，可以编写如下语句：

    ptr = &pooh; //把pooh的地址赋给ptr
在这条语句中，我们说ptr“指向”pooh。ptr和&pooh的区别是ptr是变量，而&pooh是常量。

### 间接运算符* (解引用运算符)

间接运算符后跟一个指针或者地址时，*给出储存在指针指向地址上的值

假设已知ptr指向bah:

    ptr = &bah;
然后可以使用间接运算符*找出储存在bah中的值，该运算符有时也称为解引用运算符(dereferencing operator)：

    val = *ptr;
这个上一条语句放在一起相当于：

    val = bah;

### 声明指针

example:

    int * pi;            //pi是指向int类型变量的指针
    char * pc;           //pc是指向char类型变量的指针
    float * pf, * pg;    //pf,pg都是指向float类型变量的指针
    /*更好的理解方法：既然*ptr表示的是该地址上的值，那么int *ptr的意思就是该值是int类型的，即ptr是指向int类型的指针

指针的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。

### 使用指针在函数间通信

假设要在一个函数中更改其他函数的变量。

example 1:

    int main(void)
    {
        int x = 5, y = 10;
        printf("Originally x = %d and y = %d.\n", x, y);
        interchange(x, y);
        printf("Now x = %d and y = %d.\n", x, y);
        return = 0;
    }

    void interchange(int u, int v)
    {
        int temp;
        temp = u;
        u = v;
        v = temp;
    }
然而这个程序并不会按照你的意图来运行！main函数中的两个值并不会交换！

实际上，interchange()函数没有问题，它交换了u和v的值。但是在把结果传回main()时，交换u和v的值对x和y的值没有影响。

**使用指针的解决方案**

    void interchange(int * u, int * v);

    int main(void)
    {
        int x = 5, y = 10;
        printf("Originally x = %d and y = %d.\n", x, y);
        interchange(&x, &y);                               //把地址发送给函数
        printf("Now x = %d and y = %d.\n", x, y);
        return 0;
    }

    void interchange(int * u, int * v)
    {
        int temp;
        temp = *u;      //temp获得u所指向对象的值
        *u = *v;
        *v = temp;
    }
分析：interchange()函数传递的不是x和y的值，而是它们的地址。函数要交换的是x和y的值，而不是它们的地址，所以不能写成 temp = u，要写成temp = *u。在通过把x和y的地址输送给interchange()之后，就实现了interchange()可以修改主调函数中的变量的过程。函数可以访问储存在这些位置的值并改变它们。
如果不这样做，interchange()和main()中的变量的地址是不同的，意味着是不同的变量，修改interchange()中的变量并不会对main()中的变量造成影响

**NOTE**：scanf()函数就是这样。当程序要把一个值读入变量时，调用的是scanf("%d", &num)。scanf()读取一个值，然后把该值储存到指定的地址上。


### 指针操作

指针的基本操作：
1. 赋值：可以把地址赋给指针。例如，用数组名、带地址运算符(&)的变量名、另一个指针进行赋值。注意，地址应该和指针类型兼容，比如不能把double类型的地址赋给指向int的指针。
2. 解引用：*运算符给出指针指向地址上储存的值
3. 取址：指针变量也有自己的地址和值。对指针而言，&运算符给出指针本身的地址。
4. 指针与整数相加：整数会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。如果相加的结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效(?)。
5. 递增指针：递增指向数组元素的指针可以让该指针移动至下一个元素。注意，指针本身的地址是不会变的，毕竟变量不会因为值发生变化就移动位置
6. 指针减去一个整数：指针必须是第一个运算对象，整数是第二个运算对象。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置(????)
7. 递减指针
8. 指针求差：可以通过计算两个指针的差值求出两元素之间的距离。差值的单位与数组类型的单位相同。只要两个指针都指向相同的数组就有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误
9. 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象


**NOTE**：
1. 千万不要解引用未初始化的指针，例如：
        int * pt;  //未初始化的指针
        *pt = 5;   //严重错误
    因为pt未被初始化，其值（地址）是一个随机值，所以不知道这个5将被储存在何处。解引用的瞬间可能会擦写已有的数据，导致程序崩溃。**创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存**。因此，在使用指针之前，必须先用已经分配的地址初始化它，例如，可以用一个现有变量的地址初始化该指针(使用带指针形参的函数时，就属于这种情况)


### 指针的兼容性

指针之间的赋值比数值类型之间的赋值要严格。

example:

    int * pt;
    int (*pa)[3];
    int ar1[2][3];
    int ar2[3][2];
    int **p2;   //一个指向指针的指针
    pt = &ar1[0][0];  //有效，这是一个int值
    pt = ar1[0];      //有效，这是一个int类型的一维数组
    pt = ar1;         //无效，这是一个内含3个int类型数组的数组
    pa = ar2;         //无效，pa指向内含3个int的数组，而ar2指向内含2个int的数组
    p2 = &pt；        //刚刚好
    *p2 = ar2[0];     //*p2是指向int的指针，ar2[0]是指向该数组首元素ar2[0][0]的指针，所以兼容

多重引用。example:

    int x = 20;
    const int y = 23;
    int * p1 = &x;
    const int * p2 = &y;
    const int ** pp2;  //一个指向指针的指针
    p1 = p2;      
    //↑不安全：把const指针赋给非const指针。这样可以用新的指针改变const指针指向的数据，执行这样的代码是未定义的
    p2 = p1; //有效
    pp2 = &p1;  //允许但不安全：嵌套指针类型赋值。而且会使const限定符失效
    *pp2 = &y； //有效。但是这将导致p1指向y(*pp2已被修改)
    *p1 = 10;   //有效。但这将改变y值，而y值是const是不能修改的
总而言之，很多结果都是未定义的(?)



## 数组(array)

数组由数据类型相同的一系列元素组成。

### 初始化数组

需要使用数组时，通过声明数组告诉编译器数组中含有多少元素和这些元素的类型。普通变量可以使用的类型，数组元素都可以使用。

example:

    float debts[20]; //从debts[0]到debts[19]
    char code[12];   //内含12个char类型元素的数组
    int powers[8] = {1,2,4,6,8,16,32,64};  
    //从ANSI C开始支持这种初始化。若被识别为语法错误，在数组声明前加上关键字static可以解决此问题。

**NOTE**：
1. 尽量用明示/#define或者直接代数字初始化数组的大小，**尽量不要用const**，原因复杂(???)
2. 若未初始化数组或者初始化数组失败，编译器会使用内存相应位置上的现有值，然后出错。
3. 存储类别警告：数组和其他变量相似，可以把数组创建成不同的存储类别(storage class)。现在只需要记住：本章描述的数组属于自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关键字static。对于其他一些存储类别的变量和数组，如果在声明时未初始化，编译器会自动把它们的值设置为0
4. 如果部分初始化数组，剩余的元素就会被初始化为0
5. 如果初始化列表的项数多于数组元素个数，编译器就会报错
6. 可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数。此时可以使用for循环计算数组的大小:

        const int days[] = {31,28,31,30,31,30,31,31,30,31};
        int index;
        for (index = 0; index < sizeof days / size of days[0]; index++)
            printf("Month %2d has %d days.\n", index + 1, days[index]);
    在此程序中，sizeof days是整个数组的大小(以字节为单位)，sizeof days[0]是第一项的大小，那么sizeof days / sizeof days[0]就是数组元素的个数。
    然而，自动计数有一个弊端：无法察觉初始化列表中的项数有误。

#### 指定初始化器 (C99)

C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素：

    int arr[6] = {[5] = 212};

**NOTE**：如果指定初始化器后面有更多的值，那么后面这些值将被用于初始化指定元素后面的元素。而如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。



### 给数组元素赋值

**NOTE**：考虑到影响执行的速度，C编译器不会检查数组的下标是否正确。在C标准中，使用越界下标的结果是未定义的。比如debts[20]就不正确，但是编译器不会查找这样的错误。当运行程序时，这会导致数据被放置在已被其他数据占用的地方，可能会破坏程序的结果甚至导致程序异常终端。

C不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。以下是一些错误的赋值形式：

    int oxen[5] = {5,3,2,8};
    int yaks[5];             //初始化都没有问题
    yaks = oxen;             //不允许
    yaks[5] = oxen[5];       //数组下标越界了。因为这两个数组的最后一个元素都是[4]
    yaks[5] = {5,3,2,8};     //不起作用(?)


### 多维数组

example:

    float rain[5][12]; //内含5个数组元素的数组，每个数组元素内含12个float类型的元素

#### 初始化二维数组

example 1: 

    int array[i][j] = 
    {
        {1,2,3,4,5},
        {6,7,8,9,10},
        {11,12,13,14,15}
    };
数据个数和数组大小不匹配的问题同样适用于这里的每一行。比如如果第一行(即第0行)只有3个值，那么就会填满前3个位置，剩下的位置用0补齐。

初始化时也可以省略内部的花括号，只保留最外面的一对花括号。
example 2:

    int sq[2][3] = {{5,6},{7,8}};
    
    /*这会生成如下数组：
    {
        {5,6,0},
        {7,8,0}
    }*/
example 3:

    int sq[2][3] = {5,6,7,8};

    /*这会生成如下数组：
    {
        {5,6,7},
        {8,0,0}
    }*/
从上两例可以看出，C中数组的排序是从上到下、从左到右的



### 指针和数组

数组表示法其实是在变相地使用指针

example: 数组名是数组首元素的地址

    flizny == &flizny[0];  //该语句成立

**NOTE**：把数组名赋给指针变量，相当于把数组第一个元素的地址赋给了指针变量，再把指针变量加上1之后，指针变量所指的就是数组的第二个元素，地址实际上是加了一个数组类型的字节长度（比如如果是double就+8）。这也是为什么声明指针的时候必须声明指针类型。

example:

    dates + 2 == &date[2];      //相同的地址
    *(dates + 2) == dates[2];   //相同的值

**NOTE**实际上，C语言标准在描述数组表示法时确实借助了指针。也就是说，定义ar[n]的意思就是*(ar+n)。可以认为*(ar+n)的意思是“到内存的ar位置，然后移动n个单元，检索储存在那里的值。”编译器编译这两种写法生成的代码相同，所以两者没有谁更有优势


### 函数、数组和指针

> example: sum_arr1.c

以数组为参数的函数，就把数组名作为实际参数，把它赋给一个指针形式参数，即该形参是一个指向特定类型的指针。因为数组名是该数组首元素的地址。

同时，该参数并未包含数组元素个数的信息。我们有几种方法让函数获得这一信息。

**第一种**就是直接认为写出数组大小。这适合那些我们知道数组大小的情况。example:

    int sum(int * ar)    //用特定的指针类型定义函数
    {
        int i;
        int total = 0;
        for (i = 0; i < 10; i++)   //假设我们知道数组有10个元素
            total += ar[i];        //这是一个算数组总和的函数; ar[i]与*(ar+i)相同
        return total;
    }

**第二种**比较灵活的方法就是把数组大小作为第二个参数。example: 

    int sum(int ar[], int n)
    {
        int i;
        int total = 0;
        for (i = 0; i < n; i++)
            total += ar[i];
        return total;
    }

**第三种**是给函数传递两个指针。第一个指针指明数组的开始处，第二个指针指明数组的结束处。
> example: sum_arr2.c

第三种

**NOTE**：
1. 关于函数的形参。其实还可以用int ar[]代替int * ar，但是这只有在函数原型或者函数定义头中才可以这样使用:
    
        int sum (int ar[], int n);
    事实上，因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。由于函数原型可以省略参数名，所以下面4种原型都是等价的:

        int sum(int *ar, int n);
        int sum(int *, int);
        int sum(int ar[], int n);
        int sum(int [], int);  //这居然也可以！！？？
2. 在程序sum_ar1.c中，marbles是一个数组，ar是一个指向marbles数组首元素的指针。因为marbles内含10个int类型的值，每个值占4字节，所以整个marbles的大小是40字节。但是ar只有8字节，因为ar并不是数组本身。利用C中数组和指针的特殊关系，可以用数组表示法来表示指针ar。
3. 在C语言中，ar[i]和*(ar+1)这两个表达式都是等价的。但是，只有当ar是指针变量时，才能使用ar++这样的表达式


### 保护数组中的数据

对于处理数组的函数，必须传递指针，因为这样效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率更高。

然而，传递地址会导致一些问题。有些函数不需要修改数组中的数据，例如计算ar[]数据组中所有元素之和。但是由于ar实际上是一个指针，所以编程错误可能会破坏原始数据。

example:

    int sum(int ar[], int n)
    {
        int i;
        int total = 0;
        for (i = 0; i < n; i++)
            total += ar[i]++;    //错误地递增了每个元素的值
        return total;
    }

预防手段：ANSI C提供了一种预防手段。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。example:

    int sum(const int ar[], int n);
    int sum(const int ar[], int n)
    {
        ...;
    }
在这种情况下，如果在函数中不小心使用类似ar[i]++的表达式，编译器会捕获这个错误，并生成一条错误信息。所以，**如果编写的函数不用修改数组，那么在声明数组形参时最好使用const**

#### 关于const

1. 把const数据或者非const数据的地址初始化为指向const的指针或为其赋值是合法的
2. 然而，只能把非const数据的地址赋给普通指针
3. 对函数的形参使用const不仅能保护数据，还能让函数处理const数组
4. 不应该把const数组名作为实参传递给要修改数组数据的函数。C标准规定，使用非const标识符修改const数据导致的结果是未定义的
5. const还能声明并初始化一个不能指向别处的指针，关键是const的位置：

        double rate[5] = {...};
        double * const pt = rate; //指针只能指向该数组的开始
6. 或者使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值：

        const double * const pt = rate; //如此就不能修改数组的值了


### 指针和多维数组

以二维数组 int ar[i][j] 为例：

1. 因为ar是数组首元素的地址，所以ar的值和&ar[0]的值相同。而ar[0]本身就是一个数组，所以ar[0]的值和它的首元素（即&ar[0][0]的值）相同。简而言之，ar[0]是一个占用一个int大小对象的地址，而ar是一个占用j个大小对象的地址。由于这个整数和内含j个整数的数组都开始于同一个地址，所以ar和ar[0]的值相同
2. 解引用：因为ar[0]是该数组首元素(ar[0][0])的地址，所以\*(ar[0])表示储存在ar[0][0]上的值。与此类似，\*ar代表该数组首元素(ar[0])的值，但是ar[0]本身是一个int类型地址的值，该值的地址是&ar[0][0]，所以*ar == ar[0] == &ar[0][0]。所以\*\*ar == *&ar[0][0] == ar[0][0]。简而言之，**ar是地址的地址，必须解引用两次才能获得原始值**。地址的地址或指针的指针就是双重间接(double indirection)的例子

**指向多维数组的指针**

假设声明一个指针变量pz指向一个二维数组。pz必须指向一个内含多个特定类型值的数组，而不是一个特定类型值。example:

    int (* pz)[j];  //pz指向一个含有j个int类型值的数组的数组

之所以要在声明中使用圆括号，是因为[]的优先级高于*。如果不这样的话：

    int * pax[j];  //错误。表示pax数组内含有j个指针，int表示数组中的指针都指向int类型的值

前面有括号的版本，*先与pz结合因此声明的是一个指向数组(内含j个int类型的值)的指针。

**NOTE**：假如pz是一个指向二维数组ar[4][2]的指针，尽管pz不是数组名，但是也可以使用pz[2][1]这样的写法。可以用数组表示法或者指针表示法来表示一个数组元素，既可以用数组名，也可以用指针名:

    zippo[m][n] == *(*(zippo + m) + n)


### 函数和多维数组

声明原型：

    void sum_rows(int ar[][COLS], int rows);
    void sum_cols(int ar[][COLS], int);        //省略形参名
    void sum_cols(int ar[3][COLS], int);      //没有问题，但是编译器会忽略3的值
    int sum2d(int (*ar) [COLS], int rows);   //另一种语法

这三种语法都是对的

**NOTE**：一般而言，声明一个指向N维数组的指针时，只能忽略最左边方括号中的值：

    int sum4d(int ar[][12][20][30], int rows);
    int sum4d(int (*ar)[12][20][30], int rows);
因为第一对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指向数据对象的类型。这两条声明是等价的，ar指向一个12x20x30的int数组


### 变长数组

example:

    define COLS 4
    int sum2d(int ar[][COLS], int rows)
    {
        ...;
    }
    int main()
    {
    //假设声明了下列数组：
    int array1[5][4];
    int array2[100][4];
    int array3[2][4];
    ...;
    }

这些数组是可以被sum2d()函数计算的，因为这些数组的列数固定为4，而行数被传递给形参rows，rows是一个变量。但是如果要计算6x5的数组，就不能使用这个函数，必须重新创建一个COLS为5的函数。**因为C规定，数组的维数必须是常量，不能用变量来代替COLS**

于是，C99新增了变长数组(variable-length array, VLA)，允许使用变量表示数组的维度。example:

    int quarters = 4;
    int regions = 5;
    double sales[regions][quarters];

变长数组有一些限制。变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明，都不能使用static或extern存储类别说明符。

**NOTE**：变长数组不是指可以修改已创建数组的大小，一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是在创建数组时可以使用变量指定数组的维度(那岂不是可以用形参传递二维数组的COLS值？)


### 复合字面量 (??????????)




## 字符串和字符串函数

字符串是以空字符(\0)结尾的char类型数组。因此，可以把数组和指针的知识应用于字符串

puts()函数，只显示字符串，而且自动在显示的字符串末尾加上换行符。

example:

    char words[81] = "I am a string in an array.";     //数组表示法
    const char * pt1 = "Something is pointing at me."; //指针表示法：表示pt1是该字符串的地址
    puts("Here are some strings:");
    puts(words);
    puts(pt1);
    words[8] = 'p';
    puts(words);

输出：

    Here are some strings；
    I am a string in an array.
    Something is pointing at me.
    I am a spring in an array.


### 定义字符串

用双引号括起来的内容称为字符串字面量(string literal)，也叫字符串常量。

从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字面量。 example:

    char greeting[50] = "Hello, and"" how are"" you"
                        " today!";
    char greeting[50] = "Hello, and how are you today!";
    //这两个表达式是等价的

字符串常量属于静态存储类别(static storage class)，这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。

**用双引号括起来的内容被视为指向该字符串储存位置的指针。**这类似于把数组名作为指向该数组位置的指针。example:

    printf("%s, %p, %c\n", "We", "are", *"space farers");

这会输出：

    We, Ox100000f61, s


### 初始化字符串

在指定数组大小时，要确保数组的元素个数至少比字符串长度多1。所有未被使用的元素都被自动初始化为\0(这里指的是char形式的空字符，不是数字字符0)

通常，让编译器确定数组的大小很方便也很合理。省略数组初始化声明中的大小，编译器会自动计算数组的大小。然而，让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。在C99新增变长数组之前，数组的大小必须是整型常量，包括由整型常量组成的表达式

字符数组名和其他数组名一样，是该数组首元素的地址。也可以用指针表示法创建字符串。example:

    const char * pt1 = "Something is pointing at me.";
    const char ar1[] = "Something is pointing at me.";

这两个声明**几乎**完全相同。pt1和ar1都是该字符串的地址。在这两种情况下，带双引号的字符串本身决定了留给字符串的存储空间。


#### 数组和指针表示字符串

**数组和指针表示法有什么不同？？**(???????????)

数组形式在计算机的内存中分配为一个内含29个元素的数组，每个元素被初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。字符串储存在静态储存区(static memory)中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中。此时字符串有两个副本，一个时在静态内存中的字符串字面量，另一个是储存在ar1数组中的字符串。**在数组形式中，ar1是地址常量。不能更改ar1，否则就改变了数组的地址。**

指针形式也使得编译器为字符串在静态存储区预留了29个元素的空间。另外，一旦开始执行程序，它会为指针变量pt1留出一个储存位置，并把字符串的地址储存在指针变量中。该变量最初指向字符串的首字符，但是它的值可以改变，可以使用递增运算符++pt1将其指向第二个字符。**字符串字面量被视为const数据，这意味着不能用pt1改变它所指向的数据。但是它本身的值可以随意改变。如果把字符串字面量拷贝给一个数组，就可以随意改变数据，除非声明为const。**

总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针


##### 实际使用的区别  (??????????)


### 字符串数组

如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二位字符数组的效率高。

但是，指针数组也有自身的缺点。指针指向的字符串字面量不能更改，而数组中的内容可以更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。


### 字符串输入

如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。

#### 分配空间

不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间，除非你编写一个处理这些任务的函数。

#### gets()函数和其不规范操作

gets()函数，读取整行输入，直到遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个C字符串。它经常和puts()函数配对使用。example:

    char words[81];
    puts("Enter a string, please.");
    gets(words);    //典型用法
    printf("Your string twice:\n");
    printf("%s\n", words);
    puts(words);
    puts("Done.");

如果输入的字符串过长，会导致缓冲区溢出(buffer overflow)，溢出的字符可能会擦写程序中的其他数据，会导致程序异常终止。

gets()函数容易产生不安全的行为。过去，有些人通过系统编程，利用gets()插入到和运行一些破坏系统安全的代码。


#### fgets()函数

> example: fgets3.c

1. fgets()函数的第二个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。
2. 如果fgets()读到一个换行符，**会把它储存在字符串中。**
3. fgets()函数的第三个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin作为参数，该标识符定义在stdio.h中
4. fgets()函数返回指向char的指针。如果一切运行顺利，该函数返回的地址与传入的第一个参数相同。但是，如果函数读到文件结尾，它将返回一个特殊的指针：空指针(null pointer)。该指针保证不会指向有效的数据，所以可用于标识这种特殊情况。在代码中，可以用数字0代替，不过在C语言中用宏NULL代替更常见。如果在读入数据时出现某些错误，该函数也返回NULL。example:

        char words[10];
        puts("Enter strings (empty lines to quit):");
        while (fgets(words, 10, stdin) != NULL && words[0] != '\n')
            fputs(words, stdout);
        puts("Done.");
    事实上，这段程序貌似对处理过长的字符串并不会出问题。事实是，每一次循环fgets()都取一段长度为9或者遇到换行符就停止的字符串，下一次读取的时候又从原位置重新读取。fputs()不会自动加换行符，所以每轮之间也不会有多余的换行符
5. 如何处理掉fgets()读入的换行符？example: 

        while (words[i] != '\n')
            i++;
        words[i] = '\0';

6. 当循环结束，仍然有字符串留在输入行怎么办？一个可行的办法是，如果目标数组装不下一整行输入，就丢弃那些多出的字符。example:

        while (getchar() != '\n')
            continue;
#### fputs()函数

1. fputs()的第二个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用stdout作为该参数
2. fputs()函数不在字符串末尾添加换行符。所以它一般和fgets()函数匹配着用，否则就会空出一行。除非该函数也不在字符串末尾添加换行符


#### gets_s()函数